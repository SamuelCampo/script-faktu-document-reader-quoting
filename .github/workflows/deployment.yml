name: Deploy to Amazon ECS

on:
  push:
    branches: ["main"]

permissions:
  contents: read
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # stop dispatch actions when push to main branch
  cancel-previous-runs:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      actions: write
    steps:
      - name: Cancel Previous Runs
        uses: styfle/cancel-workflow-action@0.9.1
        with:
          access_token: ${{ github.token }}
  deploy:
    name: Deploy
    runs-on: ubuntu-latest
    environment: production

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1
      - name: Build, tag, and push image to Amazon ECR
        id: build-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          # Build a docker container and
          # push it to ECR so that it can
          # be deployed to ECS.
          docker build -t $ECR_REGISTRY/${{ vars.ECR_REPOSITORY_NAME }}:$IMAGE_TAG .
          docker push $ECR_REGISTRY/${{ vars.ECR_REPOSITORY_NAME }}:$IMAGE_TAG

          # Get the image digest for Lambda
          IMAGE_DIGEST=$(docker inspect $ECR_REGISTRY/${{ vars.ECR_REPOSITORY_NAME }}:$IMAGE_TAG --format='{{.RepoDigests}}' | sed 's/\[//g' | sed 's/\]//g' | cut -d'@' -f2)
          echo "image_uri=$ECR_REGISTRY/${{ vars.ECR_REPOSITORY_NAME }}@$IMAGE_DIGEST" >> $GITHUB_OUTPUT
          echo "image=$ECR_REGISTRY/${{ vars.ECR_REPOSITORY_NAME }}:$IMAGE_TAG" >> $GITHUB_OUTPUT
      - name: validation exists lambda function
        run: |
          aws lambda get-function --function-name ${{ vars.AWS_LAMBDA_FUNCTION_NAME }} || {
            echo "Lambda function does not exist, creating it..."
            aws lambda create-function \
              --function-name ${{ vars.AWS_LAMBDA_FUNCTION_NAME }} \
              --package-type Image \
              --code ImageUri=${{ steps.build-image.outputs.image_uri }} \
              --role ${{ vars.AWS_LAMBDA_ROLE }} \
              --timeout 480 \
              --memory-size 3008
            
            echo "Waiting for Lambda function to be active..."
            aws lambda wait function-active --function-name ${{ vars.AWS_LAMBDA_FUNCTION_NAME }}
            echo "Lambda function is now active"
          }
      - name: update lambda function code
        run: |
          aws lambda update-function-code \
            --function-name ${{ vars.AWS_LAMBDA_FUNCTION_NAME }} \
            --image-uri ${{ steps.build-image.outputs.image_uri }}

          echo "Waiting for function code update to complete..."
          aws lambda wait function-updated --function-name ${{ vars.AWS_LAMBDA_FUNCTION_NAME }}

          # Update timeout and memory configuration
          aws lambda update-function-configuration \
            --function-name ${{ vars.AWS_LAMBDA_FUNCTION_NAME }} \
            --timeout 480 \
            --memory-size 3008
